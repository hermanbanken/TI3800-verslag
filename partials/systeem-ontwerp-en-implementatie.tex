Zoals besproken tijdens de meeting van 23 april (Pagina \pageref{sec:meeting-23-apr}), worden applicaties die Emando ontwikkelt opgedeeld in vier lagen. Deze opzet zullen wij ook aanhouden.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{style/images/Layers}
  \end{center}
  \caption{Diagram van de lagen van de applicatie}
  \label{fig:diagram-layers}
\end{figure}

\begin{description}
\item[De presentatielaag] verzorgt de weergave. De presentatielaag bevind zich in de code van de mobiele applicatie en bevat zowel platform onafhankelijke View-Models en hulpmiddelen als platform specifieke User Interface elementen.
\item[De servicelaag] is de interface tussen de server en de mobiele apps. Deze gebruikt de twee technieken SignalR en WebApi.
\item[De businesslaag] is verantwoordelijk voor het ophalen en verwerken van de data. Deze laag bevat een verbinding met de service- en datalaag. Met deze verbindingen is deze laag is staat met behulp van logica data op te halen, te verwerken, eventueel op te slaan en door te sturen naar de servicelaag. 
\item[De datalaag] is verantwoordelijk voor alle verschillende databronnen: Entity Framework, Table Storage, MyLaps*
\end{description}

Naast deze vier lagen is er ook nog een deel van de code die gedeeld wordt door alle andere lagen: ``cross-cutting''. In de cross-cutting laag bevinden zich voornamelijk de domein entiteiten, zodat alle server-lagen deze entiteiten kunnen gebruiken. Naast de entiteiten wordt ook de JSON serialisatie van de entiteiten in de cross-cutting laag geregeld: er zijn  speciale te serialiseren afgeleide modellen, met zo weinig afhankelijkheden van frameworks dat ze in een \ac{pcl} kunnen. Hierdoor kunnen de mobiele applicaties dezelfde modellen gebruiken als de servicelaag, en kunnen de modellen via de Websockets- en HTTP-verbinding van SignalR en WebAPI verstuurd worden.

  % 4 lagen
  % - presentatie laag
  % - service laag: API
  % - business laag: analyse en aggregatie
  % - data laag
  
\input{partials/server-datalaag}
\section{Businesslaag}
  De businesslaag bestaat uit meerdere grote onderdelen. Zowel aggregatie als de workflows zijn twee gescheiden onderdelen die zich in de businesslaag bevinden.
 
\begin{figure}[ht]
  \includegraphics[width=\textwidth]{style/images/Businesslaag}    
  \caption{Opbouw en interactie van de businesslaag}  
  \label{fig:lagen-businesslaag}
\end{figure}
  
  
  \input{partials/server-businesslaag-pipes-filters-aggregatie}
  \input{partials/server-businesslaag-workflows}
  
\section{Servicelaag}
  \input{partials/server-servicelaag}
  \input{partials/client-servicelaag}

\section{Presentatielaag}
  De presentatielaag bevind zich in de mobiele applicatie. Hieronder komen enkele karakteristieke onderdelen aan bod.
  \input{partials/client-presentatielaag}

\section{Testomgeving}
Er zijn maar een paar gedeelten van de App die effectief automatisch getest kunnen worden. Dit heeft te maken met het feit dat de App de data die van de server komt, bijna letterlijk overneemt in views. Het testen van views komt erop neer dat er automatisch zou worden getest of er dingen op het scherm verschijnen, wat erg veel werk zou zijn voor iets wat heel simpel handmatig getest kan worden.

{\par \bigskip \par \color{red} TODO: Uitbreiden, Visual Studio Testomgeving toelichten, iOS Testomgeving en tests toelichten \par \bigskip \par }

Binnen het server-gedeelte van de applicatie worden alle transponder-doorkomsten realtime verwerkt. De filters die te maken hebben met het verwerken van deze doorkomsten worden uitgebreid getest om er zeker van te zijn dat ze correct functioneren. Dit testen wordt gedaan met een set unit-tests die elk van deze filters aanroept met bepaalde input en controleert of de uitvoer overeenkomt met de verwachte uitvoer van deze filters.

\subsection{Integratietesten van client en server}
Een bijkomend voordeel van het hebben van een platformonafhankelijke client is dat deze ook uit te voeren is op hetzelfde platform als waar de server draait. Het is erg fijn om op deze manier te kunnen controleren of de server en client code integreerd, aangezien je snel door zowel de server als de client kan `steppen' - het regel voor regel door de lopende applicatie heen stappen tijdens het debuggen - in Visual Studio.

Het is niet mogelijk een test van het hele platform te automatiseren op zo'n manier dat alles op een test-server draait. Voor het uitvoeren van het Azure project is een Azure Queue nodig die alleen in de Cloud bestaat. Azure is alleen te bereiken met de Azure SDK die alleen voor Visual Studio beschikbaar is, en dus alleen op Windows werkt, terwijl de Xamarin projecten voor iOS alleen op een MacBook kunnen opstarten. Om een speciale Mac test-server op te zetten met daarop een virtuele machine met Windows was te veel werk voor dit project, dus worden integratie-tests uitgevoerd op onze persoonlijke MacBooks, waar we deze set-up wel hebben ge√Ønstalleerd.

% TODO: we moeten nog integratie tests schrijven in iOS.Test